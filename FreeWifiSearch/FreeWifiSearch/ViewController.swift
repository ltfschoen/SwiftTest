//
//  ViewController.swift
//  FreeWifiSearch
//
//  Created by LS on 2/09/2015.
//  Copyright Â© 2015 LS. All rights reserved.
//

// Progress: Page 204

/* Questions:
   - Why the postfixes of "!" required in code "func mapView(mapView: MKMapView!, didFailToLocateUserWithError error: NSError!) {" on page 180?
   - Why warning "Value of Optional type CLLocation not unwrapped, consider adding ! at the end"  that requires changing to code to "self.centerMapOnLocation(newLocation!)" and "self.fetchFreeWifiHotspotsAroundLocation(newLocation!)", even though no ! is shown on page 181?
   - When entering code for NSURLConnection.sendAsynchronousRequest it autocompletes with default code, then when I Double Click the default value of completionHandler in the following code to convert it into Block format:
         NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue(), completionHandler: (NSURLResponse?, NSData?, NSError?) -> Void )
    ... it converts into Block format as follows.
         NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue()) { (NSURLResponse?, NSData?, NSError?) -> Void in INSERT CODE }
    ... Why does it give error "Expected '.' separator" unless I explicitly provide the prefix for "response:", "data:", and "error:" Properties as follows? And why doesn't it give the same error when "request" is not given the prefix "request:" (page 187)?
   - When use the JSONObjectWithData it shows the following in the autocomplete annotation popup
       JSONObjectWithData(data: NSData, options: NSJSONReadingOptions) throws
    ... but after pressing Tab why doesn't it add Swifts optional "error: &error" parameter shown on page 187 for use with Cocoa APIs?
   - Why do I get error "Extra argument 'error' in call" when using the following code, and why do they choose to instead use a separate do/catch block to cater for any errors in the solution code, as this is not mentioned in tbe book on page 187 or 188 in the Fetching Data from Facebook section:
       let jsonObject: AnyObject! = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(0), error: &error)
   - Why does the code block "if !FBSession.activeSession().isOpen { }" contain a "return" statement, as it prevents the subsequent code from being run (such as building urlString to allow the user to login to Facebook)? Shouldn't this "return" statement be removed and the existing "if" statement be extended with an "else" statement containing the rest of the code in the method "fetchCafesAroundLocation" ?
*/

import UIKit
import MapKit

class ViewController: UIViewController {

    /* Constant (in Units of Meters) defining:
       - Extent of searching for Free Wifi from User Location
       - Distance for User to move before app Auto Refresh
    */
    let searchDistance: CLLocationDistance = 1000

    /* Property Declarations that hook variables in Interface Builder (IB). IBOutlets are set implicitly unwrapped as Optional Type prefixed with ! (so IBOutlets may be used without checking for nil but runtime crash will occur if value is nil) since IB supplies Views at Runtime the Swift Compiler does not know and would give error that variables values not set in all initializers, so do not use an IBOutlet before the View of the ViewController has loaded. IBOutlets are declared as weak by default since the View of a ViewController holds Strong References to its outlets
    */
    @IBOutlet weak var mapView: MKMapView!
    @IBOutlet weak var loginView: FBLoginView! // FBLoginView instead of UIView

    private var locationManager: CLLocationManager!

    /* Store Last Location of a User with CLLocation object that represents device geographical location data (including 2D coordinate, altitude, accuracy) generated by CLLocationManager object. Optional as may not yet have their Last Location
    */
    private var lastLocation: CLLocation?

    /* Property Definition to hold list of Free Wifi Hotspots the Map is currently displaying
    */
    private var freeWifiHotspots = [FreeWifiHotspot]()

    override func viewDidLoad() {

        print("ViewController.swift - Loading viewDidLoad overrides")

        super.viewDidLoad()

        self.locationManager = CLLocationManager()

        // Delegate Object for updated events
        self.locationManager.delegate = self

        /* Target-Action Pattern where Target is "self" (returns the View Controller receiver instance). "refresh:" is the Selector (Named Parameter) that searches for the "refresh" Method (where Selector conforms to StringLiteralConvertible Protocol and such may be converted directly from a String Literal)
        */
        self.navigationItem.leftBarButtonItem = UIBarButtonItem(barButtonSystemItem: .Refresh, target: self, action: "refresh:")

    }

    override func viewDidAppear(animated: Bool) {

        print("ViewController.swift - Loading viewDidAppear overrides")

        super.viewDidAppear(animated)

        self.checkLocationAuthorizationStatus()
    }

    private func checkLocationAuthorizationStatus() {

        if CLLocationManager.authorizationStatus() == .AuthorizedWhenInUse {

            print("ViewController.swift - Location Auth Status is true")

            // Display the User's Location if User has provided authorisation
            self.mapView.showsUserLocation = true

        } else {

            print("ViewController.swift - Location Auth Status is false")

            self.locationManager.requestWhenInUseAuthorization()
        }
    }

    // Centers Map View on location passed in as a parameter
    private func centerMapOnLocation(location: CLLocation) {

        print("ViewController.swift - Centering on Map Location\n\(location.coordinate.latitude) & \(location.coordinate.longitude)")

        /* Visible extent of map region is defined based on searchDistance constant (sized sufficiently to display all Free Wifi Hotspots
        */
        let coordinateRegion = MKCoordinateRegionMakeWithDistance(location.coordinate,
                                                                  searchDistance,
                                                                  searchDistance)

        // Change currently visible region (of MKCoordinateRegion type) and animates the change
        self.mapView.setRegion(coordinateRegion, animated: true)
    }

    /* Stub Method displays error when Facebook Session not open (User not logged in) since Facebook Graph API requires a User Access Token to allow the app to fetch the data it needs and as such the user must first Login to Facebook
    */
    private func fetchFreeWifiHotspotsAroundLocation(location: CLLocation) {

        if !FBSession.activeSession().isOpen {

            print("ViewController.swift - No Facebook Session detected")

            let alert = UIAlertController(title: "Error", message: "Access Denied. Please Login...", preferredStyle: .Alert)
            alert.addAction(UIAlertAction(title: "OK",
                                          style: .Default,
                                          handler: nil))

            self.presentViewController(alert, animated: true, completion: nil)

            return

        }

        print("ViewController.swift - Facebook Session detected")

        // Fetch Free Wifi Hotspots from Facebook

        /* Construct URL (using String Interpolation) to Fetch nearby Free Wifi Locations matching search term "free wifi"
        */
        var urlString = "https://graph.facebook.com/v2.0/search/"
        urlString += "?access_token="
        urlString += "\(FBSession.activeSession().accessTokenData.accessToken)"
        urlString += "&type=place"
        urlString += "&q=wifi"
        urlString += "&center=\(location.coordinate.latitude),"
        urlString += "\(location.coordinate.longitude)"
        urlString += "&distance=\(Int(searchDistance))"

        // Convert String to NSURL
        let url = NSURL(string: urlString)!

        print("Requesting from Facebook with URL: \(url)")

        let request = NSURLRequest(URL: url)

        // Interface controls to start and cancel async loads of specific URL requested
        /* Note: Info.plist updated to overcome error "NSURLSession/NSURLConnection HTTP load failed" by adding new key NSAppTransportSecurity nested dictionary containining NSAllowsArbitraryLoads with a value of true (iOS9 exclusive HTTPS use to enforce secure connection)
        */
        NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue()) { (response: NSURLResponse?, data: NSData?, error: NSError?) -> Void in

            // Completion Handler Block

            // Display error when unable to fetch data due to connection failure
            if error != nil {

                let alert = UIAlertController(
                    title: "Error:",
                    message: "Connection error occurred",
                    preferredStyle: .Alert)

                alert.addAction(UIAlertAction(title: "OK", style: .Default, handler: nil))

                self.presentViewController(alert, animated: true, completion: nil)

                return
            }

            // JSON Deserialisation of Data from Facebook Graph API
            var error: NSError?

            /* Error parameter traditionally used as common pattern in Objective-C Cocoa development for interfacing with Cocoa APIs is optional in Swift and caters for the fact that Methods cannot return multiple values. Pass to the Method a Pointer reference to an Optional NSError (error variable) object so a Reference to an error (if any) may be assigned. NSJSONSerialization returns an NSDictionary. Instead of using extra parameter "error: &error" we use a do/catch block
            */
            let jsonObject: AnyObject!

            do {
                jsonObject = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions(rawValue: 0))
            } catch var error1 as NSError {
                error = error1
                jsonObject = nil
            } catch {
                fatalError()
            }

            /* Attempt to Downcast jsonObject variable into a dictionary of String to AnyObject without error to confirm retrieval of valid data from API. Expect Facebook Graph API return value from JSON deserialisation to be JSON Object.
            */
            if let jsonObject = jsonObject as? [String:AnyObject] {

                if error == nil {
                    print("Fetched Data from Facebook:\n\(jsonObject)")

                    /* Use JSONValue Helper from JSON.swift to address uncertainty of type contained inside JSON object by parsing the whole JSON structure into an enumeration with a case for each type JSON supports. Optional Chaining is used to extract the "data" Key from the JSON, cast its value to an array containing the nearby locations.
                    */
                    if let data = JSONValue.fromObject(jsonObject)?["data"]?.array {

                        // New Array to hold Free Wifi Hotspots to be parsed out of "data" array
                        var freeWifiHotspots: [FreeWifiHotspot] = []

                        for freeWifiHotspotJSON in data {
                            if let freeWifiHotspotJSON = freeWifiHotspotJSON.object {

                                /* Use fromJSON Method in FreeWifiHotspot.swift to Parse the JSON Data and Append the New freeWifiHotspot Object to the Array of freeWifiHotspots
                                */
                                if let freeWifiHotspot = FreeWifiHotspot.fromJSON(freeWifiHotspotJSON) {
                                    freeWifiHotspots.append(freeWifiHotspot)
                                }

                            }
                        }

                        // Remove existing Free Wifi Hotspots from Map and Replace with new Free Wifi Hotspots
                        self.mapView.removeAnnotations(self.freeWifiHotspots)
                        self.freeWifiHotspots = freeWifiHotspots
                        self.mapView.addAnnotations(freeWifiHotspots)

                    }
                }
            }
        }
    }

    // Target-Action Pattern passes the button/control (UIBarButtonItem) that caused the "refresh" Method to run
    func refresh(sender: UIBarButtonItem) {
        if let location = self.lastLocation {
            // Center Map on Location. Fetch Data of Free Wifi Hotspots when user moved and presses "refresh" button
            self.centerMapOnLocation(location)
            self.fetchFreeWifiHotspotsAroundLocation(location)
        } else {
            // Error when Location not yet obtained
            let alert = UIAlertController(title: "Error", message: "Location not yet obtained", preferredStyle: .Alert)
            alert.addAction(UIAlertAction(title: "OK", style: .Default, handler: nil))
            self.presentViewController(alert, animated: true, completion: nil)
        }
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }

}

/* Declare conformance to the CLLocationManagerDelegate Protocol that defines methods to receive location and heading updates from CLLocationManager Object
*/
extension ViewController: CLLocationManagerDelegate {

    // Communicates to Delegate that authorization status for app changed
    func locationManager(manager: CLLocationManager, didChangeAuthorizationStatus status: CLAuthorizationStatus) {

        print("ViewController.swift - Authorisation Status Changed")

        self.checkLocationAuthorizationStatus()
    }

}

/* Declare conformance to the MKMapViewDelegate Protocol that defines methods that the Map View uses to communicate app related update messages about events to the View Controller (such as a User's Location)
*/
extension ViewController: MKMapViewDelegate {

    /* Tell Map View attempt to get User's Location fails to update (i.e. GPS failure) and show alert
    */
    func mapView(mapView: MKMapView!, didFailToLocateUserWithError error: NSError!) {

        print("ViewController.swift - Failed to Locate User with Error:\n\(error)")

        let alert = UIAlertController(title: "Error", message: "Unable to obtain User's Location", preferredStyle: .Alert)

        // UIAlertAction is action taken when tap an alert action
        alert.addAction(UIAlertAction(title: "OK", style: .Default, handler: nil))

        // Modally present the ViewController
        self.presentViewController(alert, animated: true, completion: nil)
    }

    // Called when Map View updates User's Location
    func mapView(mapView: MKMapView!, didUpdateUserLocation userLocation: MKUserLocation!) {

        print("ViewController.swift - Updating the User Map Location to:\n\(userLocation.location?.coordinate.latitude) & \(userLocation.location?.coordinate.longitude)")

        /* Retrieve new location from MKMapViewDelegate's method userLocation that is an annotation object of CLLocation type (lat/long) representing User's Current location that returns nil if User's location is yet to be determined or if owning MKMapView's showsUserLocation is NO (i.e. User has not authorized use of their location)
        */
        let newLocation = userLocation.location

        /* Return distance from current location to the last location stored, where the lastLocation is an Optional Property Value as its value may be nil. If lastLocation is nil then nil is returned and processing stops, else distanceFromLocation is called on lastLocation.
           Without the use of Optionals we would have to decipher between when no distance value exists (nil) and when the distance value is 0
            i.e.
              if self.lastLocation != nil {
                let distance = self.lastLocation.distanceFromLocation(newLocation)
              }
        */
        let distance = self.lastLocation?.distanceFromLocation(newLocation!)

        print("ViewController.swift - Updating the User Map Location with Distance:\n\(distance)")

        /* When no previous lastLocation or if User has moved more than the defined searchDistance radius we store the latest location and trigger an Auto Refresh by centering map on the new location and fetching nearby free wifi hotspots
        */
        if distance == nil || distance! > searchDistance {
            self.lastLocation = newLocation
            self.centerMapOnLocation(newLocation!)
            self.fetchFreeWifiHotspotsAroundLocation(newLocation!)
        }
    }

    /* Map View Delegate called when Map View needs a view returned to display an annotation (button in callout accessory that requires handling when user taps button using calloutAccessoryControlTapped)
    */
    func mapView(mapView: MKMapView!, viewForAnnotation annotation: MKAnnotation!) -> MKAnnotationView! {

        /* Conditional Downcast to only handle FreeWifiHotspot annotation Objects (not other annotations such as User Location)
        */
        if let annotation = annotation as? FreeWifiHotspot {
            let identifier = "pin"
            var view: MKPinAnnotationView

            /* Attemping to dequeue existing annotation in a Reuse Queue (avoid unnecessary recreate annotations coming into view).
               Conditional Downcast ensures view type MKPInAnnotationView
            */
            if let dequeuedView = mapView.dequeueReusableAnnotationViewWithIdentifier(identifier) as? MKPinAnnotationView {

                /* Case where a view is dequeued. Set annotation only on the view that is dequeued
                */
                dequeuedView.annotation = annotation
                view = dequeuedView

            } else {

                /* Case where no view is dequeued. Create new MKPinAnnotationView. Setup to show button as callout accessory.
                */
                view = MKPinAnnotationView(annotation: annotation, reuseIdentifier: identifier)
                view.canShowCallout = true
                view.calloutOffset = CGPoint(x: -5, y: 5)
                view.rightCalloutAccessoryView = UIButton(type:.DetailDisclosure) as UIView
            }

            return view
        }

        return nil
    }

    // Method called to handle when user taps button in callout accessory
    func mapView(mapView: MKMapView!, annotationView view: MKAnnotationView!, calloutAccessoryControlTapped control: UIControl!) {

        /* Create new instance of FreeWifiHotspotViewController using Storyboard ID already set. Conditional Optional Unwrapping to account for failure (where nil returned)
        */
        if let viewController = self.storyboard!.instantiateViewControllerWithIdentifier("FreeWifiHotspotView") as? FreeWifiHotspotViewController {

            /* Check annotation from tapped view is FreeWifiHotspot Object explicitly since type of annotation is MKAnnotation (Compiler does not know this)
            */
            if let freeWifiHotspot = view.annotation as? FreeWifiHotspot {
                // Setup ViewController
                viewController.freeWifiHotspot = freeWifiHotspot

                /* Declare ViewController Instance using Custom Definition of FreeWifiHotspotViewController Delegate (in FreeWifiHotspotViewController.swift). Use the Delegate to tell the ViewController when user presses the Back Button (when finished with FreeWifiHotspotViewController)
                */
                viewController.delegate = self

                // Present the ViewController
                self.presentViewController(viewController, animated: true, completion: nil)
            }
        }
    }

}

/* Declare Conformance to Custom Protocol (using Delegate Pattern) and Implement its Optional Method (to dismiss the ViewController when user presses the Back button)
*/
extension ViewController: FreeWifiHotspotControllerDelegate {

    func freeWifiHotspotViewControllerDidFinish(viewController: FreeWifiHotspotViewController) {
        self.dismissViewControllerAnimated(true, completion: nil)
    }
}