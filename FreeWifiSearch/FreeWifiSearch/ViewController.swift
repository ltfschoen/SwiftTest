//
//  ViewController.swift
//  FreeWifiSearch
//
//  Created by LS on 2/09/2015.
//  Copyright Â© 2015 LS. All rights reserved.
//

// Progress: Page 183

/* Questions:
   - Why the postfixes of "!" required in code "func mapView(mapView: MKMapView!, didFailToLocateUserWithError error: NSError!) {" on page 180?
   - Why warning "Value of Optional type CLLocation not unwrapped, consider adding ! at the end"  that requires changing to code to "self.centerMapOnLocation(newLocation!)" and "self.fetchFreeWifisAroundLocation(newLocation!)", even though no ! is shown on page 181?
*/

import UIKit
import MapKit

class ViewController: UIViewController {

    /* Constant (in Units of Meters) defining:
       - Extent of searching for Free Wifi from User Location
       - Distance for User to move before app Auto Refresh
    */
    let searchDistance: CLLocationDistance = 1000

    /* Property Declarations that hook variables in Interface Builder (IB). IBOutlets are set implicitly unwrapped as Optional Type prefixed with ! (so IBOutlets may be used without checking for nil but runtime crash will occur if value is nil) since IB supplies Views at Runtime the Swift Compiler does not know and would give error that variables values not set in all initializers, so do not use an IBOutlet before the View of the ViewController has loaded. IBOutlets are declared as weak by default since the View of a ViewController holds Strong References to its outlets
    */
    @IBOutlet weak var mapView: MKMapView!
    @IBOutlet weak var loginView: FBLoginView! // FBLoginView instead of UIView

    private var locationManager: CLLocationManager!

    /* Store Last Location of a User with CLLocation object that represents device geographical location data (including 2D coordinate, altitude, accuracy) generated by CLLocationManager object. Optional as may not yet have their Last Location
    */
    private var lastLocation: CLLocation?

    override func viewDidLoad() {
        super.viewDidLoad()

        self.locationManager = CLLocationManager()

        // Delegate Object for updated events
        self.locationManager.delegate = self

    }

    override func viewDidAppear(animated: Bool) {
        super.viewDidAppear(animated)

        self.checkLocationAuthorizationStatus()
    }

    private func checkLocationAuthorizationStatus() {
        if CLLocationManager.authorizationStatus() == .AuthorizedWhenInUse {

            // Display the User's Location if User has provided authorisation
            self.mapView.showsUserLocation = true

        } else {
            self.locationManager.requestWhenInUseAuthorization()
        }
    }

    // Centers Map View on location passed in as a parameter
    private func centerMapOnLocation(location: CLLocation) {

        /* Visible extent of map region is defined based on searchDistance constant (sized sufficiently to display all Free Wifi Hotspots
        */
        let coordinateRegion = MKCoordinateRegionMakeWithDistance(location.coordinate,
                                                                  searchDistance,
                                                                  searchDistance)

        // Change currently visible region (of MKCoordinateRegion type) and animates the change
        self.mapView.setRegion(coordinateRegion, animated: true)
    }

    /* Stub Method displays error when Facebook Session not open (User not logged in) since Facebook Graph API requires a User Access Token to allow the app to fetch the data it needs and as such the user must first Login to Facebook
    */
    private func fetchFreeWifisAroundLocation(location: CLLocation) {

        if !FBSession.activeSession().isOpen {

            let alert = UIAlertController(title: "Error", message: "Access Denied. Please Login...", preferredStyle: .Alert)
            alert.addAction(UIAlertAction(title: "OK",
                                          style: .Default,
                                          handler: nil))

            self.presentViewController(alert, animated: true, completion: nil)

            return

        }

        // TODO

    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }

}

/* Declare conformance to the CLLocationManagerDelegate Protocol that defines methods to receive location and heading updates from CLLocationManager Object
*/
extension ViewController: CLLocationManagerDelegate {

    // Communicates to Delegate that authorization status for app changed
    func locationManager(manager: CLLocationManager, didChangeAuthorizationStatus status: CLAuthorizationStatus) {
        self.checkLocationAuthorizationStatus()
    }

}

/* Declare conformance to the MKMapViewDelegate Protocol that defines methods that the Map View uses to communicate app related update messages about events to the View Controller (such as a User's Location)
*/
extension ViewController: MKMapViewDelegate {

    /* Tell Map View attempt to get User's Location fails to update (i.e. GPS failure) and show alert
    */
    func mapView(mapView: MKMapView!, didFailToLocateUserWithError error: NSError!) {

        print(error)

        let alert = UIAlertController(title: "Error", message: "Unable to obtain User's Location", preferredStyle: .Alert)

        // UIAlertAction is action taken when tap an alert action
        alert.addAction(UIAlertAction(title: "OK", style: .Default, handler: nil))

        // Modally present the ViewController
        self.presentViewController(alert, animated: true, completion: nil)
    }

    // Called when Map View updates User's Location
    func mapView(mapView: MKMapView!, didUpdateUserLocation userLocation: MKUserLocation!) {

        /* Retrieve new location from MKMapViewDelegate's method userLocation that is an annotation object of CLLocation type (lat/long) representing User's Current location that returns nil if User's location is yet to be determined or if owning MKMapView's showsUserLocation is NO (i.e. User has not authorized use of their location)
        */
        let newLocation = userLocation.location

        /* Return distance from current location to the last location stored, where the lastLocation is an Optional Property Value as its value may be nil. If lastLocation is nil then nil is returned and processing stops, else distanceFromLocation is called on lastLocation.
           Without the use of Optionals we would have to decipher between when no distance value exists (nil) and when the distance value is 0
            i.e.
              if self.lastLocation != nil {
                let distance = self.lastLocation.distanceFromLocation(newLocation)
              }
        */
        let distance = self.lastLocation?.distanceFromLocation(newLocation!)

        /* When no previous lastLocation or if User has moved more than the defined searchDistance radius we store the latest location and trigger an Auto Refresh by centering map on the new location and fetching nearby free wifi hotspots
        */
        if distance == nil || distance! > searchDistance {
            self.lastLocation = newLocation
            self.centerMapOnLocation(newLocation!)
            self.fetchFreeWifisAroundLocation(newLocation!)
        }
    }

}